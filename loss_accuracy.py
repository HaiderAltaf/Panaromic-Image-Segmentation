# -*- coding: utf-8 -*-
"""Loss_accuracy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w-PlBwER6xgrBfV9WUNdn0R2mb-Xa865

#function to find the accuracy
"""

from question_2 import forward_propagation

def model_accuracy(X, Y, Weights, bias, hid_layer, acti_fun,weight_init):
  """
  This function calculate the accuracy at the given parameters
  during training or testing of the model.
  X- input values
  Y- class labels
  Weights- of the model(after training)
  bias- of the model(after training)
  acti_fun - cross_entropy or mse
  weight_init - random or xavier initialisation of the weights & biases

  """ 
  L = hid_layer
  y_pred = np.zeros((len(X), 10))
  i=0
  for x in X:
    _, _, y_dash = forward_propagation(Weights, bias, x, L, acti_fun, weight_init)
    y_pred[i] = y_dash
    i+=1

  correct = 0
  for array,y in zip(y_pred, Y):
    if np.argmax(array)==y:
      correct+=1
  accuracy = correct*100/len(X)

  return  accuracy

"""function to find the loss"""

def model_loss(X, Y, Weights, bias, hid_layer, loss_fu,
               L2_decay, X_train, acti_fun,weight_init):
  """
  This function calculate the error/loss at the given parameters
  during training or testing of the model.
  X- input values
  Y- class labels
  Weights- of the model(after training)
  bias- of the model(after training)
  acti_fun - cross_entropy or mse
  weight_init - random or xavier initialisation of the weights & biases
  L2_decay - decay rate of l2 regularisation

  """
  L = hid_layer
  loss = 0
  for x,y in zip(X, Y):
      _, _, y_dash = forward_propagation(Weights, bias, x, L, acti_fun, weight_init)
      
      if loss_fu == 'cross_entropy':
#         if y_dash[y]==0:
#             continue
        loss+= -np.log2(y_dash[y])
      elif loss_fu == 'mse':
        y_train_modified = np.zeros(10)
        y_train_modified[y] = 1
        loss1 = (np.sum((y_dash - y_train_modified)**2))
   
#   # Adding L2 regularization loss after an epochS
  loss2 = 0
  for i in range(len(Weights)):
    loss2+= L2_decay*np.sum(Weights[i]**2)
  
  loss = (loss+loss2)/len(X)

  return loss